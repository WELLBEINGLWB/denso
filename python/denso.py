from pylab import *
from numpy import *
import scipy.optimize
import Trajectory

TINY = 1e-5

# Simple class to handle a chunk of the velocity profile
class Chunk(object):
    def __init__(self,t0,v0,t1,v1):
        assert(t1-t0>0)
        self.t0 = t0
        self.v0 = v0
        self.t1 = t1
        self.v1 = v1
        self.acc = (v1-v0)/(t1-t0)
        self.T = t1-t0
        self.ndof = len(v0)

    def Shift(self,tshift):
        self.t0 += tshift
        self.t1 += tshift
        
    def SetStart(self,tstart):
        self.t0 = tstart
        self.t1 = tstart + self.T
    
    def SetDuration(self,newT):
        self.T = newT
        self.t1 = self.t0 + newT

    def Plot(self,color):
        for i in range(self.ndof):
            plot([self.t0,self.t1],[self.v0[i],self.v1[i]],color[i],linewidth=2)


# Compute the optimal velocity profile between q0 and q1 given the max velocities and accelerations
def ComputeChunks(q0,q1,vmaxl,amaxl,tstart):
    reslist = []
    ndof = len(q0)
    vmax = 1e10
    amax = 1e10
    for i in range(ndof):
        if abs(q1[i]-q0[i])>TINY:
            vmax = min(vmaxl[i]/abs(q1[i]-q0[i]),vmax)
            amax = min(amaxl[i]/abs(q1[i]-q0[i]),amax)
    tp = sqrt(1/amax)
    a = (q1-q0)*amax
    if tp*amax <= vmax :
        v = (q1-q0)*tp*amax
        reslist.append(Chunk(tstart,zeros(ndof),tstart+tp,v))
        reslist.append(Chunk(tstart+tp,v,tstart+2*tp,zeros(ndof)))
    else:
        v = (q1-q0)*vmax
        t = vmax/amax
        t2 = 1/vmax - vmax/amax
        reslist.append(Chunk(tstart,zeros(ndof),tstart+t,v))
        reslist.append(Chunk(tstart+t,v,tstart+t+t2,v))
        reslist.append(Chunk(tstart+t+t2,v,tstart+2*t+t2,zeros(ndof)))
    return reslist


# Merge the decelerating chunka with the following sequence chunksb
# of 2 (accel,decel) or 3 chunks (accel,max velocity,decel)
def MergeChunks(chunka,chunkbs):
    for i in range(chunka.ndof):
        assert(abs(chunka.v1[i])<TINY)
        assert(abs(chunkbs[0].v0[i])<TINY)
    reslist = []
    if(len(chunkbs)==2 or chunka.T<chunkbs[0].T or chunkbs[1].T<(chunka.T-chunkbs[0].T)/2.):
        chunkb = chunkbs[0]
        chunkbb = chunkbs[1]
        if(chunka.T>=chunkb.T):
            tadd = chunka.T - chunkb.T
            tnew = chunka.t0 + tadd
            vnew = chunka.v0+chunka.acc*tadd
            tnew2 = chunka.t1
        else:
            tadd = chunka.T
            tnew = chunka.t1
            vnew = tadd*chunkb.acc
            tnew2 = chunka.t0+chunkb.T
        if(tnew - chunka.t0 >= TINY):
            reslist.append(Chunk(chunka.t0,chunka.v0,tnew,vnew))
        if(tnew2-tnew >= TINY):
            reslist.append(Chunk(tnew,vnew,tnew2,chunkb.v1))
        chunkbb.SetStart(tnew2)
        reslist.append(chunkbb)
        if(len(chunkbs)==3):
            chunkbbb = chunkbs[2]
            chunkbbb.SetStart(chunkbb.t1)
            reslist.append(chunkbbb)
    else: 
        # here chunksb has size 3 and chunka.T >= chunkbs[0].T and chunkbs[1].T>=(chunka.T-chunkbs[0].T)/2.)
        # in this case, we connect the two max velocities by a straight line
        # and compensate by reducing the time duration of chunksb[1] by (chunka.T-chunkbs[0].T)/2.
        chunkb = chunkbs[0]
        chunkbb = chunkbs[1]
        chunkbbb = chunkbs[2]
        tnew = chunka.t0+chunka.T
        reslist.append(Chunk(chunka.t0,chunka.v0,tnew,chunkb.v1))
        chunkbb.SetStart(tnew)
        chunkbb.SetDuration(chunkbb.T-(chunka.T-chunkb.T)/2.)
        reslist.append(chunkbb)
        chunkbbb.SetStart(chunkbb.t1)
        reslist.append(chunkbbb)    
    return reslist


# Make a TOPP chunk from a velocity chunk and initial dof values
def MakeTOPPChunk(vchunk,q0):
    polylist = []
    for i in range(vchunk.ndof):
        polylist.append(Trajectory.Polynomial([q0[i],vchunk.v0[i],0.5*(vchunk.v1[i]-vchunk.v0[i])/vchunk.T]))
    return Trajectory.Chunk(vchunk.T,polylist)


# Compute the full trajectory that would be generated by denso given a sequence of waypoints
def Interpolate(qlist0,vmax,amax,tstart=0):
    assert(len(qlist0)>=3)
    qlist = list(qlist0)
    q0 = qlist.pop(0)
    qcur = qlist.pop(0)
    reslist =  ComputeChunks(q0,qcur,vmax,amax,tstart)
    while(len(qlist)>0):            
        qnext = qlist.pop(0)
        chunkslistb =  ComputeChunks(qcur,qnext,vmax,amax,0)
        chunka = reslist.pop(-1)
        listmerge = MergeChunks(chunka,chunkslistb)
        reslist.extend(listmerge)
        qcur = qnext
    # Make a TOPP Trajectory
    topplist = []
    qcur = qlist0[0]
    for i in range(len(reslist)):
        toppchunk = MakeTOPPChunk(reslist[i],qcur)
        qcur = toppchunk.Eval(toppchunk.duration)
        topplist.append(toppchunk)
    return Trajectory.PiecewisePolynomialTrajectory(topplist)
               

# Objective function for waypoint optimization
def ObjFunc(x,qstart,qend,ndof,nwaypoints,nsamples,weights,vmax,amax,trajref):
    assert(len(x) == ndof*nwaypoints)
    qlist = [qstart]
    for i in range(nwaypoints):
        qlist.append(x[i*ndof:(i+1)*ndof])
    qlist.append(qend)
    traj = Interpolate(qlist,vmax,amax,0)
    dpos, dvel, dacc = Trajectory.Diff(traj,trajref,nsamples)
    cpos, cvel, cacc, cdur = weights
    cost = cpos*dpos*dpos + cvel*dvel*dvel + cacc*dacc*dacc + cdur*(traj.duration-trajref.duration)
    print cost, cpos*dpos*dpos, cvel*dvel*dvel, cacc*dacc*dacc, cdur*(traj.duration-trajref.duration)
    return cost
    

# Find the optimal sequence of waypoints to track a reference trajectory
def FindOptTraj(trajref,nwaypoints,nsamples,weights,vmax,amax):
    ndof = trajref.dimension
    qstart = trajref.Eval(0)
    qend = trajref.Eval(trajref.duration)
    x0 = zeros(ndof*nwaypoints)
    waypoints = linspace(0,trajref.duration,nwaypoints+2)
    for i in range(1,nwaypoints+1):
        x0[(i-1)*ndof:i*ndof] = trajref.Eval(waypoints[i])
    xopt = scipy.optimize.fmin_powell(ObjFunc,x0,args=(qstart,qend,ndof,nwaypoints,nsamples,weights,vmax,amax,trajref))
    qlist = [qstart]
    for i in range(nwaypoints):
        qlist.append(xopt[i*ndof:(i+1)*ndof])
    qlist.append(qend)
    return Interpolate(qlist,vmax,amax,0),qlist
        

# Array to string
def arraytostring(a):
    if len(a) < 1:
        return ""
    restring = str(a[0])
    for i in range(1,len(a)):
        restring += "," + str(a[i])
    return restring


# Create a denso pcs program from a sequence of waypoints
def CreateProgram(qlist, filename, nextracols=0):
    ndof = len(qlist[0])
    fullvalues = zeros(ndof+nextracols)

    restring = "Sub Main \n TakeArm Keep = 1\n"

    # First waypoint    
    fullvalues[0:ndof] = qlist[0]*180/pi  
    restring += "  Move P, @E J(" + arraytostring(fullvalues)  + ")\n" 
    restring += "  Delay 1000\n"

    # Intermediate waypoints
    for i in range(1,len(qlist)-1):
        fullvalues[0:ndof] = qlist[i]*180/pi  
        restring += "  Move P, @P J(" + arraytostring(fullvalues)  + ")\n" 

    # Final waypoint
    fullvalues[0:ndof] = qlist[-1]*180/pi
    restring += "  Move P, @E J(" + arraytostring(fullvalues)  + ")\n" 

    restring += "End Sub\n"    
    handle = open(filename,"w")
    handle.write(restring)
    handle.close()


# Plot the kinematics of the trajectories
def PlotKinematics(traj0, traj1, dt=0.01, vmax=[], amax=[], figstart=0, colorcycle = ['r', 'g', 'b', 'm', 'c', 'y', 'k'],tstart=0):
    from pylab import figure, clf, hold, gca, title, xlabel, ylabel, plot, axis
    colorcycle = colorcycle[0:traj0.dimension]
    if traj0 is None:
        Tmax = traj1.duration
    elif traj1 is None:
        Tmax = traj0.duration
    else:
        Tmax = max(traj0.duration, traj1.duration)

    # Joint angles
    figure(figstart)
    hold('on')
    ax = gca()
    ax.set_color_cycle(colorcycle)
    if(traj0!=None):
        traj0.Plot(dt, f='--',tstart=tstart)
    ax.set_color_cycle(colorcycle)
    if(traj1!=None):
        traj1.Plot(dt,tstart=tstart)
    title('Joint values', fontsize=20)
    xlabel('Time (s)', fontsize=18)
    ylabel('Joint values (rad)', fontsize=18)

    # Velocity
    figure(figstart + 1)
    hold('on')
    ax = gca()
    ax.set_color_cycle(colorcycle)
    if(traj0!=None):
        traj0.Plotd(dt, f='--',tstart=tstart)
    ax.set_color_cycle(colorcycle)
    if(traj1!=None):
        traj1.Plotd(dt,tstart=tstart)
    for v in vmax:
        plot([0, Tmax], [v, v], '-.')
    for v in vmax:
        plot([0, Tmax], [-v, -v], '-.')
    if len(vmax) > 0:
        Vmax = 1.2 * max(vmax)
        if Vmax < 0.1:
            Vmax = 10
        axis([0, Tmax, -Vmax, Vmax])
    title('Joint velocities', fontsize=20)
    xlabel('Time (s)', fontsize=18)
    ylabel('Joint velocities (rad/s)', fontsize=18)

    # Acceleration
    figure(figstart + 2)
    ax = gca()
    ax.set_color_cycle(colorcycle)
    hold('on')
    if(traj0!=None):
        traj0.Plotdd(dt, f='--',tstart=tstart)
    ax.set_color_cycle(colorcycle)
    if(traj1!=None):
        traj1.Plotdd(dt,tstart=tstart)
    for a in amax:
        plot([0, Tmax], [a, a], '-.')
    for a in amax:
        plot([0, Tmax], [-a, -a], '-.')
    if len(amax) > 0:
        Amax = 1.2 * max(amax)
        axis([0, Tmax, -Amax, Amax])
    title('Joint accelerations', fontsize=20)
    xlabel('Time (s)', fontsize=18)
    ylabel('Joint accelerations (rad/s^2)', fontsize=18)


# Detect the onset of a signal
def detect_onset(a,start = 0,threshold = 0.01):
    i = start
    while i<len(a):
        if(abs(a[i])>threshold):
            return i
        i+=1
    return -1

